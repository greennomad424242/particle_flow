<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Sample Three.js</title>
		<style>
			#container {
				background: #000;
				width: 400px;
				height: 300px;
			}
		</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/100/three.js"></script>


		<script src="BufferGeometryUtils.js"></script>

	</head>
	<body>

		<div id="container">


		</div>

	</body>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>


	<script type="text/javascript">

	// @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       ||
              window.webkitRequestAnimationFrame ||
              window.mozRequestAnimationFrame    ||
              window.oRequestAnimationFrame      ||
              window.msRequestAnimationFrame     ||
              function(/* function */ callback, /* DOMElement */ element){
                window.setTimeout(callback, 1000 / 60);
              };
    })();
	// set the scene size
	var WIDTH = 400,
	    HEIGHT = 300;
			var particleCount = 18;

var pickingData=[];
	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = WIDTH / HEIGHT,
	    NEAR = 0.1,
	    FAR = 10000;

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#container');

	// create a WebGL renderer, camera
	// and a scene
	var renderer = new THREE.WebGLRenderer();
	var camera = new THREE.Camera(  VIEW_ANGLE,
	                                ASPECT,
	                                NEAR,
	                                FAR  );
	var scene = new THREE.Scene();

	// the camera starts at 0,0,0 so pull it back
	camera.position.z = 300;

	// start the renderer - set the clear colour
	// to a full black
	renderer.setClearColor(new THREE.Color(0, 1));
	renderer.setSize(WIDTH, HEIGHT);

	// attach the render-supplied DOM element
	$container.append(renderer.domElement);

	// create the particle variables
	var
	    particles = new THREE.Geometry(),
		pMaterial = new THREE.ParticleBasicMaterial({
			color: 0xFFFFFF,
			size: 20,
			map: THREE.ImageUtils.loadTexture(
				"images/particle.png"
			),
			blending: THREE.AdditiveBlending,
			transparent: true
		});

    // TO DO : create webpages

		function applyVertexColors( geometry, color ) {
			 var position = geometry.attributes.position;
			 var colors = [];
			 for ( var i = 0; i < position.count; i ++ ) {
				 colors.push( color.r, color.g, color.b );
			 }
			 geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
		 }

		var pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

		var defaultMaterial = new THREE.MeshLambertMaterial(
				{ color:  0xfffddd,
				 emissive: 0xe6e600,
				 emissiveIntensity:1,
				 opacity: 0.5,
				 transparent: false,
				 vertexColors: 0xdddddd	} );
var actual_array =[];


side_length=5;
axis_length=100;
var min_x=0,min_y=0,min_z=0;
var max_x=100, max_y=100, max_z=100;

actual_array.push([10,10,10]);
actual_array.push([20,20,20]);
		 var geometriesDrawn = [];
		 var linesDrawn = [];
		 var geometriesPicking = [];
		 var matrix = new THREE.Matrix4();
		 quaternion = new THREE.Quaternion();
		 var color = new THREE.Color();
		 var num_rows = actual_array.length;
		 for ( var i = 0; i < num_rows ; i ++ ) {
			 var geometry = new THREE.BoxBufferGeometry();
			 var position = new THREE.Vector3();
			 sample_x = actual_array[i][0];
			 sample_y = actual_array[i][1];
			 sample_z = actual_array[i][2];
			 target_x = Math.round((sample_x - min_x)/(max_x - min_x) * axis_length);
			 target_y = Math.round((sample_y - min_y)/(max_y - min_y) * axis_length);
			 target_z = Math.round((sample_z - min_z)/(max_z - min_z) * axis_length);
			 position.x = target_x ;  //Math.random() * 10000 - 5000;
			 position.y = target_y;//Math.random() * 6000 - 3000;
			 position.z = 	target_z;//Math.random() * 8000 - 4000;
			 var rotation = new THREE.Euler();
			 rotation.x = 0;
			 rotation.y = 0;
			 rotation.z = 0;
			 var scale = new THREE.Vector3();
			 scale.x = side_length ;
			 scale.y = side_length ;
			 scale.z = side_length ;
			 quaternion.setFromEuler( rotation, false );
			 matrix.compose( position, quaternion, scale );
			 geometry.applyMatrix( matrix );
						 // give the geometry's vertices a random color, to be displayed
			 var edges = new THREE.EdgesGeometry( geometry );
			 var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
			 scene.add( line);
			 applyVertexColors( geometry, color.setHex(  0x009900 ) );
			 linesDrawn.push( line );
			 geometriesDrawn.push( geometry );
			 geometry = geometry.clone();
						 // give the geometry's vertices a color corresponding to the "id"
			 applyVertexColors( geometry, color.setHex( i ) );
			 geometriesPicking.push( geometry );
			 pickingData[ i ] = {
				 position: position,
				 rotation: rotation,
				 scale: scale
			 };
		 }

		 var objects = new THREE.Mesh( THREE.BufferGeometryUtils.mergeBufferGeometries( geometriesDrawn ), defaultMaterial );

					 //objects.add( edges );
		 scene.add( objects );





	// now create the individual particles
	for(var p = 0; p < 0; p++) {

		// create a particle with random
		// position values, -250 -> 250
		var pX = 0 + p*2,
			pY = 200+p*2,
			pZ = 0 + p*2,
		    particle = new THREE.Vertex(
				new THREE.Vector3(pX, pY, pZ)
			);
		// create a velocity vector
		particle.velocity = new THREE.Vector3(
			0,				// x
			-1,	// y
			0);				// z

		// add it to the geometry
		particles.vertices.push(particle);
	}

	// create the particle system
	var particleSystem = new THREE.ParticleSystem(
		particles,
		pMaterial);

	particleSystem.sortParticles = true;

	// add it to the scene
	//scene.addChild(particleSystem);

	// animation loop
	function update() {

		// add some rotation to the system
	//	particleSystem.rotation.y += 0.00;

		//var pCount = particleCount;
	//	while(pCount--) {
//			// get the particle
//		var particle = particles.vertices[pCount];
//
			// check if we need to reset
//			if(particle.position.y < -200) {
	//			particle.position.y = 200;
		//		particle.velocity.y = -1;
//	/	}
//


			// and the position
//			particle.position.addSelf(
	//			particle.velocity);
		//}

		// flag to the particle system that we've
		// changed its vertices. This is the
		// dirty little secret.
		//particleSystem.geometry.__dirtyVertices = true;

		renderer.render(scene, camera);

		// set up the next call
		requestAnimFrame(update);
	}
	requestAnimFrame(update);
	</script>
</html>
