<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Interactive Cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


		<script src="three.js"></script>
		<link rel="shortcut icon" href="favicon.ico">
		<script src="TrackballControls.js"></script>
		<script src="BufferGeometryUtils.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://cdn.rawgit.com/Gmousse/dataframe-js/master/dist/dataframe.js"></script>



		<link rel='stylesheet' href='styles.css'/>

	</head>
	<body>
		<body>
			<div class="grid2x2">
			  <div class="box box1">
			  	<div id="titlebar">Multi-dimensional Display
					</div>
					<span id="axis_select">Select axes:</span>


					<div id="instructions">
					<span id="emphasis"> Instructions: </span><ul>

							 <li><span id="emphasis">Rotate</span>: mouse &amp; hold A
					  <li><span id="emphasis">Zoom</span>: mouse &amp; hold S
						<li><span id="emphasis">Pan</span>: mouse &amp; hold D
							<li><span id="emphasis">Auto-rotate start/stop</span>: press w
							</ul>
				 </div>

					<div  id="axes_values" class="box_view">
					</div>
					<div id="data_box" class="box_view">
					</div>

			  </div>
			  <div class="box box2" id="main_area">
				</div>
      </div>
<script>

var myFile = "wine.csv";
var X_text,Y_text, Z_text, camera,group;

var axis_text_size =5;
var picked_var;
var speed_multiplier =70;
var axis_text_height = 1;
var x_color = '#cc0000';
var y_color  = '#009900' ;
var z_color  = '#0000e6';
var rotSpeed =0;
var opacity_value = 1;
var rotateSpeed =2;
var zoomSpeed=4;
var panSpeed=2;
var angle = 1;
var min_x=0,min_y=0, min_z =0;
var max_x=100, max_y=100, max_z=100;
var delta =  0.005;
var camera_x = 15;
var camera_y = 80;
var camera_z = 80;
var radius = Math.sqrt(camera_x* camera_x + camera_y* camera_y+ camera_z*camera_z );
var side_length = 2;
var picked_length = 4;
var width = window.innerWidth -200;
var height = window.innerHeight;
var axis_length = 100;
var X_text,Y_text, Z_text;
var container, camera, controls, scene, renderer,  quaternion, num_rows, actual_array;
var pickingData = [], pickingTexture, pickingScene;
var highlightBox;
var mouse = new THREE.Vector2();
var DataFrame = dfjs.DataFrame;
var offset = new THREE.Vector3( picked_length, picked_length, picked_length );
var orbit_default;

// whether we rotate around
var x = localStorage.getItem('orbit_default');
if (x) {
	orbit_default = x;
} else {
	orbit_default = 0;
	localStorage.setItem('orbit_default',0); // orbit_default
}




function render() {
	controls.update();
//	pick();
	renderer.render( scene, camera );
}

document.addEventListener("keydown", onDocumentKeyDown, false);

function onDocumentKeyDown(event) {
		var keyCode = event.which;
		if (keyCode == 87) {  //A for action
      if (orbit_default == 0 ) {
        orbit_default =1;
			}  else {
       orbit_default =0;
			}
      localStorage.setItem('orbit_default',orbit_default);
		}
};

function pickHex(color1, color2, weight) {
    var w1 = weight;
    var w2 = 1 - w1;
    var rgb = [Math.round(color1[0] * w1 + color2[0] * w2),
        Math.round(color1[1] * w1 + color2[1] * w2),
        Math.round(color1[2] * w1 + color2[2] * w2)];
    return rgb;
}

filter_data();

function filter_data() {
	var angle = 1;
	var delta =  0.005;
  page_array = [];
  traffic_array =[];

	page_array.push({ id: 1, name:"home", x:10,y:10,z:10} );
	page_array.push({ id: 2, name:"about", x:20, y:10,z:10} );
	page_array.push({ id: 3, name:"product", x:30,y:10,z:10} );
  page_array.push({ id: 4, name:"checkout", x:30,y:10,z:10} );

 traffic_array.push({ id: 1, step: 0, type:'enter', src: 0, dest: 1});

 traffic_array.push({ id: 1, step: 1, type:'transit', src: 1, dest: 2});
 traffic_array.push({ id: 1, step: 2, type:'transit', src: 2, dest: 3});
 traffic_array.push({ id: 1, step: 3, type:'exit', src: 3, dest: 0});
 traffic_array.push({ id: 2, step: 0, type:'enter', src: 0, dest: 2});
 traffic_array.push({ id: 2, step: 1, type:'exit', src: 2, dest: 0});

	display(page_array);
}

function applyVertexColors( geometry, color ) {
	 var position = geometry.attributes.position;
	 var colors = [];
	 for ( var i = 0; i < position.count; i ++ ) {
		 colors.push( color.r, color.g, color.b );
	 }
	 geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
 }

function display() {
	//initial setup
 container = document.getElementById("main_area" );
 renderer = new THREE.WebGLRenderer( { antialias: true } );
 renderer.setPixelRatio( window.devicePixelRatio );
 renderer.setSize( width, height );
 container.appendChild( renderer.domElement );
 renderer.domElement.addEventListener( 'mousemove', onMouseMove );

 camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
 camera.position.x = camera_x;
 camera.position.y = camera_y;
 camera.position.z = camera_z;
 //
 // Controls
 //
 controls = new THREE.TrackballControls( camera, renderer.domElement );
 controls.rotateSpeed = 3.0;
 controls.zoomSpeed = 6.4;
 controls.panSpeed = 2.8;
 controls.noZoom = false;
 controls.noPan = false;
 controls.staticMoving = true;
 controls.dynamicDampingFactor = 0.2;
 scene = new THREE.Scene();

	//Lights

 scene.background = new THREE.Color( 0x000000 );
 pickingScene = new THREE.Scene();
 pickingTexture = new THREE.WebGLRenderTarget( 1, 1 );
 scene.add( new THREE.AmbientLight( 0x555555 ) );
 var light = new THREE.SpotLight( 0xffffff, 1.5 );
 light.position.set( 220, 200, 200 );
 //scene.add( light );


//CylinderGeometry(radiusTop : Float, radiusBottom : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)

const textureLoader = new THREE.TextureLoader();

 // Load a texture. See the note in chapter 4 on working locally, or the page
 // https://threejs.org/docs/#manual/introduction/How-to-run-things-locally
 // if you run into problems here
 const texture = textureLoader.load( 'chevron.png' );

 texture.anisotropy = 16;

 // create a Standard material using the texture we just loaded as a color map
 material = new THREE.MeshLambertMaterial( {
	 map: texture,	 emissiveIntensity:0
 } );



 var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );

 var cylinder = new THREE.Mesh( geometry, material );
 scene.add( cylinder );

 var light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
 scene.add( light2 );

 var lightHelper = new THREE.SpotLightHelper(light);
//	scene.add (lightHelper);

 var pickingMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

 var defaultMaterial = new THREE.MeshLambertMaterial(
	   { color:  0xfffddd,
			emissive: 0xe6e600,
			emissiveIntensity:1,
			opacity: opacity_value,
			transparent: false,
			vertexColors: 0xdddddd	} );



	var geometriesDrawn = [];
	var linesDrawn = [];
	var geometriesPicking = [];
	var matrix = new THREE.Matrix4();
	quaternion = new THREE.Quaternion();
	var color = new THREE.Color();
  var num_rows = page_array.length;

	//
	// Create the Pages
	//

  for ( var i = 0; i < num_rows ; i ++ ) {
	  var geometry = new THREE.BoxBufferGeometry();
		var position = new THREE.Vector3();
    sample_x = page_array[i].x;
 		sample_y = page_array[i].y;
 		sample_z = page_array[i].z;
 		target_x = Math.round((sample_x - min_x)/(max_x - min_x) * axis_length);
 		target_y = Math.round((sample_y - min_y)/(max_y - min_y) * axis_length);
 		target_z = Math.round((sample_z - min_z)/(max_z - min_z) * axis_length);
		position.x = target_x ;  //Math.random() * 10000 - 5000;
		position.y = target_y;//Math.random() * 6000 - 3000;
		position.z = 	target_z;//Math.random() * 8000 - 4000;
		var rotation = new THREE.Euler();
		rotation.x = 0;
		rotation.y = 0;
		rotation.z = 0;
		var scale = new THREE.Vector3();
		scale.x = side_length ;
		scale.y = side_length ;
		scale.z = side_length ;
		quaternion.setFromEuler( rotation, false );
		matrix.compose( position, quaternion, scale );
		geometry.applyMatrix( matrix );
					// give the geometry's vertices a random color, to be displayed
		var edges = new THREE.EdgesGeometry( geometry );
    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x000000 } ) );
  	scene.add( line);
		applyVertexColors( geometry, color.setHex(  0x009900 ) );
	  linesDrawn.push( line );
		geometriesDrawn.push( geometry );
		geometry = geometry.clone();
					// give the geometry's vertices a color corresponding to the "id"
		applyVertexColors( geometry, color.setHex( i ) );
		geometriesPicking.push( geometry );
		pickingData[ i ] = {
			position: position,
			rotation: rotation,
			scale: scale
		};
	}


	var objects = new THREE.Mesh( THREE.BufferGeometryUtils.mergeBufferGeometries( geometriesDrawn ), defaultMaterial );
	scene.add( objects );

	//
	//  Cubes
	//
	var geometry = new THREE.BoxGeometry( 1, 1, 1 );
	// Create the Material passing the color
	var material = new THREE.MeshBasicMaterial( { color: "#5c5cd6" } );

	cube = new THREE.Mesh( geometry, material );
	group = new THREE.Group();

// create a cube for each row of data
	var selected_data = $.grep(traffic_array, function(v) {
			return v.step ==  0;
	});
  var num_rows = selected_data.length;

	var dir = new THREE.Vector3( 10, 2, 0 );

	//normalize the direction vector (convert to vector of length 1)
	dir.normalize();

	var origin = new THREE.Vector3( 0, 0, 0 );
	var length = 5;
	var headWidth = 2;
	var headLength = 3;

	var hex = 0xffff00;

	var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex, headLength , headWidth );
	scene.add( arrowHelper );

  //for each cube
	for ( var i = 1; i < num_rows+1 ; i ++ ) {
	  // look up where the cube is starting from
	 	cube.userData.id = i;
		cube.userData.step = -1;
		cube.userData.hold = 0;
		next_step(cube);
		instance = cube.clone();
		group.add(instance );
	}
	scene.add(group );
  animate() ;
}

function onMouseMove( e ) {
	event.preventDefault();
	mouse.x = e.clientX -200;
	mouse.y = e.clientY;
}



function animate() {

 var l = group.children.length;
 for (var i = 0; i < l; i++) {
	 object = group.children[i];
   if (object.userData.hold ==1) {

   } else if ((object.userData.end_x > object.position.x &&  object.userData.velocity_x <0  ) ||
	    (object.userData.end_x < object.position.x &&  object.userData.velocity_x >0  ) ||
	    (object.userData.end_y >  object.position.y &&  object.userData.velocity_y <0  ) ||
	    (object.userData.end_y <  object.position.y &&  object.userData.velocity_y >0  ) ||
	  	(object.userData.end_z >  object.position.z &&  object.userData.velocity_z <0  ) ||
			(object.userData.end_z <  object.position.z &&  object.userData.velocity_z >0  )) {

     next_step(object);

   } else {
			object.translateX(object.userData.velocity_x);
			object.translateY(object.userData.velocity_y);
			object.translateZ(object.userData.velocity_z);
	 }
 }

 for (var i = group.children.length - 1; i >= 0; i--) {
	 if (group.children[i].userData.delete == 1) {
	   group.remove(group.children[i]);
   }
}

 requestAnimationFrame( animate );
 render();
}

function pick() {
	//render the picking scene off-screen
	// set the view offset to represent just a single pixel under the mouse
	camera.setViewOffset( renderer.domElement.width, renderer.domElement.height, mouse.x * window.devicePixelRatio | 0, mouse.y * window.devicePixelRatio | 0, 1, 1 );
	// render the scene
	renderer.render( pickingScene, camera, pickingTexture );
	// clear the view offset so rendering returns to normal
	camera.clearViewOffset();
	//create buffer for reading single pixel
	var pixelBuffer = new Uint8Array( 4 );
	//read the pixel
	renderer.readRenderTargetPixels( pickingTexture, 0, 0, 1, 1, pixelBuffer );

	var allZeroes =  pixelBuffer.reduce(function(prev, item) {
    return prev && (item === 0.0);
  }, true);

	if (allZeroes) {
    highlightBox.visible = false;
    document.getElementById('data_box').innerHTML="";
		$('#data_box').hide();
  } else {
    $('#data_box').show();

		//interpret the pixel as an ID
		var id = ( pixelBuffer[ 0 ] << 16 ) | ( pixelBuffer[ 1 ] << 16 ) | ( pixelBuffer[ 2 ] );
		var data = pickingData[ id ];

		if ( data ) {
			//move our highlightBox so that it surrounds the picked object
			if ( data.position && data.rotation && data.scale ) {
				highlightBox.position.copy( data.position );
				highlightBox.rotation.copy( data.rotation );
				highlightBox.scale.copy( data.scale ).add( offset );
				highlightBox.visible = true;

		  }
		} else {
					highlightBox.visible = false;
		}
  }
}

function next_step(object) {
  //
	// find th
	console.log("id:" + object.userData.id);
	console.log("step:" + object.userData.step);
  //console.log(traffic_array);
	var selected_data = $.grep(traffic_array, function(v) {
			return v.step ==  (object.userData.step + 1) &&  v.id ==  (object.userData.id) ;
	});


  if (selected_data[0]) {

	var src = selected_data[0].src ;
	var dest = selected_data[0].dest ;
  var type = selected_data[0].type ;

  var start_box = $.grep(page_array, function(v) {
		return v.id ==  src;
  });

  var end_box = $.grep(page_array, function(v) {
		return v.id == dest;
  });

  if (type  =="enter")  {
		sample_x1 = end_box[0].x;
	  sample_y1 = end_box[0].y;
	  sample_z1 = end_box[0].z-10;

	} else {
	 sample_x1 = start_box[0].x;
	 sample_y1 = start_box[0].y;
	 sample_z1 = start_box[0].z;
}

if (type  =="exit")  {
	sample_x2 = start_box[0].x;
	sample_y2 = start_box[0].y;
	sample_z2 = start_box[0].z+10;

} else {
	 sample_x2 = end_box[0].x;
	 sample_y2 = end_box[0].y;
	 sample_z2 = end_box[0].z;

}

object.userData.start_x = Math.round((sample_x1 - min_x)/(max_x - min_x) * axis_length);
object.userData.start_y = Math.round((sample_y1 - min_y)/(max_y - min_y) * axis_length);
object.userData.start_z = Math.round((sample_z1 - min_z)/(max_z - min_z) * axis_length);
object.userData.end_x= Math.round((sample_x2 - min_x)/(max_x - min_x) * axis_length);
object.userData.end_y = Math.round((sample_y2 - min_y)/(max_y - min_y) * axis_length);
object.userData.end_z = Math.round((sample_z2 - min_z)/(max_z - min_z) * axis_length);
object.userData.velocity_x = (object.userData.end_x - object.userData.start_x )/speed_multiplier;
object.userData.velocity_y =(object.userData.end_y - object.userData.start_y )/speed_multiplier;
object.userData.velocity_z = (object.userData.end_z - object.userData.start_z )/speed_multiplier;
object.position.x = object.userData.start_x;
object.position.y = object.userData.start_y;
object.position.z = object.userData.start_z;
object.userData.step +=1 ;
object.userData.hold = 0;
} else {
object.userData.delete = 1;
}


//return object

}




</script>
</body>
</html>
