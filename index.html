<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Interactive Cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="three.js"></script>
		<link rel="shortcut icon" href="favicon.ico">
		<script src="TrackballControls.js"></script>

		<script src="ParametricGeometries.js"></script>
		<script src="BufferGeometryUtils.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script src="https://cdn.rawgit.com/Gmousse/dataframe-js/master/dist/dataframe.js"></script>
		<link rel='stylesheet' href='styles.css'/>
	</head>
	<body>
		<body>
     <div  id="main_area">
  </div>
<script>

var axis_text_size =5;
var page_height = 15;
var page_diameter = 5;
var speed_multiplier =70;
var axis_text_height = 1;
var safe_distance =3;
var texture_in_offset =0.01;
var texture_inter_offset =0.01;
var texture_out_offset =0.01;
var texture_out;


var x_color = '#cc0000';
var y_color  = '#009900' ;
var z_color  = '#0000e6';
var rotSpeed =0;
var opacity_value = 1;
var rotateSpeed =2;
var zoomSpeed=4;
var panSpeed=2;
var angle = 1;
var min_x=0,min_y=0, min_z =0;
var max_x=100, max_y=100, max_z=100;
var delta =  0.005;
var camera_x = 15;
var camera_y = 80;
var camera_z = 80;
var radius = Math.sqrt(camera_x* camera_x + camera_y* camera_y+ camera_z*camera_z );

var picked_length = 0;
var width = window.innerWidth;
var height = window.innerHeight;
var axis_length = 100;
var X_text,Y_text, Z_text;
var picked_var;
var container, camera, controls, scene, renderer,  quaternion,
 num_rows,page_inbound , interpage_traffic, actual_array, pickingData = [], pickingTexture, pickingScene, X_text,Y_text, Z_text, camera,group;
var highlightBox, orbit_default;
var mouse = new THREE.Vector2();
var DataFrame = dfjs.DataFrame;
var offset = new THREE.Vector3( picked_length, picked_length, picked_length );
var texture_in,   texture_inter;

//  ---- minor functions
var population, state_locations, migration;
var state_data = [];

//used to parse json objects
function getObjects(obj, key, val) {
    var objects = [];
    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        if (typeof obj[i] == 'object') {
            objects = objects.concat(getObjects(obj[i], key, val));
        } else if (i == key && obj[key] == val) {
            objects.push(obj);
        }
    }
    return objects;
}

// get the state information (population, lat, long)
var jqxhr = $.getJSON( "capitals.json", function(data) {
  state_locations = data;
	var population = $.getJSON( "population.json", function(data) {
	  population = data;
    for (j=0; j < population.length ; j++)  {
      var temp = getObjects(state_locations, 'name', population[j].state);
			state_data.push ([population[j].state, population[j].population, temp[0].lat,
			temp[0].long]);
		}
		console.log(state_data);
		var jqxhr = $.getJSON( "migration.json", function(data) {
			 migration = data;
			console.log(migration);
			 display();
		});
	});
});


///the flows


document.addEventListener("keydown", onDocumentKeyDown, false);


function y_from_pop(population)  {
	return  population/1000000
}



function onDocumentKeyDown(event) {
		var keyCode = event.which;
		if (keyCode == 87) {  //A for action
      if (orbit_default == 0 ) {
        orbit_default =1;
			}  else {
       orbit_default =0;
			}
      localStorage.setItem('orbit_default',orbit_default);
		}
};

function pickHex(color1, color2, weight) {
    var w1 = weight;
    var w2 = 1 - w1;
    var rgb = [Math.round(color1[0] * w1 + color2[0] * w2),
        Math.round(color1[1] * w1 + color2[1] * w2),
        Math.round(color1[2] * w1 + color2[2] * w2)];
    return rgb;
}

function applyVertexColors( geometry, color ) {
	 var position = geometry.attributes.position;
	 var colors = [];
	 for ( var i = 0; i < position.count; i ++ ) {
		 colors.push( color.r, color.g, color.b );
	 }
	 geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
 }











/*----- Data structure

 page_array
  - page_id
  - name
	- x
	- y
	- z

	page_inbound
  - page_id
	- channel
	- volume

 interpage_traffic
	- id
	- src
	- dest
	- volume

*/





function display() {
	//initial setup
 container = document.getElementById("main_area" );
 renderer = new THREE.WebGLRenderer( { antialias: true } );
 renderer.setPixelRatio( window.devicePixelRatio );
 renderer.setSize( width, height );
 container.appendChild( renderer.domElement );

 camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
 camera.position.x = camera_x;
 camera.position.y = camera_y;
 camera.position.z = camera_z;
 //
 // Controls
 //
 controls = new THREE.TrackballControls( camera, renderer.domElement );
 controls.rotateSpeed = 3.0;
 controls.zoomSpeed = 6.4;
 controls.panSpeed = 2.8;
 controls.noZoom = false;
 controls.noPan = false;
 controls.staticMoving = true;
 controls.dynamicDampingFactor = 0.2;
 scene = new THREE.Scene();


 axis = new THREE.AxesHelper(axis_length);
 	scene.add(axis);

	//Lights

 scene.background = new THREE.Color( 0x000000 );
 pickingScene = new THREE.Scene();
 pickingTexture = new THREE.WebGLRenderTarget( 1, 1 );
 scene.add( new THREE.AmbientLight( 0x555555 ) );
 var light = new THREE.SpotLight( 0xffffff, 1.5 );
 light.position.set( 220, 200, 200 );
 //scene.add( light );

 var light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
 scene.add( light2 );

 var lightHelper = new THREE.SpotLightHelper(light);
//	scene.add (lightHelper);


//
// Create the Pages
//
 var num_rows = state_data.length;
 page_group = new THREE.Group();


 const textureLoader = new THREE.TextureLoader();
 texture_page = textureLoader.load( 'brick.png', function ( texture ) {
	 texture.wrapS = THREE.RepeatWrapping;
	 texture.wrapT = THREE.RepeatWrapping;
	 texture.repeat.set( 4, 4 );
 } );

 texture_page.anisotropy = 1;

 material_page = new THREE.MeshLambertMaterial( {
	 map: texture_page,	 emissiveIntensity:0
 } );

  console.log(state_data);
 for (var k=0; k<state_data.length; k++) {
  var radius = 33;//state_data[k].population/100000;
	page_height = radius*3;
	var y_from_size = y_from_pop(state_data[k][1]);
	var x_from_lat = state_data[k][2]*10;
	var z_from_long = Math.abs(parseInt(state_data[k][3]*10));
  //console.log(state_data[k]);
	var geometry = new THREE.CylinderBufferGeometry(radius, radius,  page_height, 32 );

	var cylinder = new THREE.Mesh( geometry, material_page );
	var edges = new THREE.EdgesGeometry( geometry );
	var line = new THREE.Line( edges, new THREE.LineBasicMaterial( { color: 0x818281 } ) );

	cylinder.position.x = x_from_lat;
	cylinder.position.y = y_from_size;
	cylinder.position.z = z_from_long;

	line.position.x = x_from_lat;;
	line.position.y = y_from_size;
	line.position.z = z_from_long;

	var instance = cylinder.clone();
	page_group.add( instance );
	var line_instance = line.clone();
	page_group.add( line_instance );
}
scene.add(page_group);


texture_inter = textureLoader.load( 'black_arrow.png', function ( texture ) {
	texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set( 8, 8 );
 } );

texture_inter.anisotropy = 1;
material_inter = new THREE.MeshLambertMaterial( {
 map: texture_inter,	 emissiveIntensity:0
} );
interpage_group = new THREE.Group();

for (q=0; q < 1; q++) {  //migration.length
	var src_page = $.grep(state_data, function(v) {
			 return v[0] ==  migration[q].Origin ;
	});
	var dest_page = $.grep(state_data, function(v) {
			 return v[0] ==  migration[q].Destination ;
  });
	var page_height = 20;


 var pointX= new THREE.Vector3();
 pointX.x= parseInt(src_page[0][2]);
 pointX.y = parseInt(y_from_pop(src_page[0][1])  + page_height/4);
 pointX.z = parseInt(src_page[0][3]);


 var pointY= new THREE.Vector3();
 pointY.x = parseInt(dest_page[0][2]);
 pointY.y = parseInt(y_from_pop(dest_page[0][1])  - page_height/4);
 pointY.z = parseInt(dest_page[0][3]);

	// smooth my curve over this many points
	var cylinder_element =  cylinderMesh(pointX, pointY, material_inter, migration[0].Total/1000);

	instance = cylinder_element.clone();
	interpage_group.add(instance );
}
 scene.add(	interpage_group );
  animate() ;
}

function cylinderMesh( point2, point1,material, volume) {
console.log(point2);
console.log(point1);
var x_delta, y_delta, z_delta;
   // point1 is always the source

   distance = Math.sqrt(
		Math.pow((point2.x -   point1.x ),2)  +
    Math.pow((point2.y -   point1.y),2)  +
		Math.pow((point2.z -   point1.z ),2)   );

   mid_x = (point1.x  + point2.x  )/2;
	 mid_y = ( point1.y + point2.y )/2 ;
	 mid_z = (point1.z  +  point2.z)/2;

   if (point1.x >= point2.x) {
     z_delta = safe_distance;
	 }
	 else {
     z_delta = -1*safe_distance;

	 }

	 if (point1.z > point2.z) {
		 x_delta = -1*safe_distance;
	}
	else {
		 x_delta = safe_distance;

	}


	var numPoints = 30;
	var path = [  point1,
	new THREE.Vector3( mid_x + x_delta ,
										mid_y,
									  mid_z+ z_delta ),
	 point2
];

	var pathBase = new THREE.CatmullRomCurve3(path);

	//path : Curve, tubularSegments : Integer, radius : Float, radialSegments : Integer, closed : Boolean)
	var geometry = new THREE.TubeGeometry(pathBase, 20, 20, 40 );
	var mesh = new THREE.Mesh( geometry, material );
  return mesh;
 }



function render() {
	controls.update();
//  texture_in.offset.y += texture_in_offset;
//	texture_out.offset.y -= texture_in_offset;
  texture_inter.offset.x += texture_inter_offset;

	renderer.render( scene, camera );
}

function animate() {
 requestAnimationFrame( animate );
 render();
}

</script>
</body>
</html>
